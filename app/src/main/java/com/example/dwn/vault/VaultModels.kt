package com.example.dwn.vault

import java.util.UUID

// ============================================
// üóÑÔ∏è UNIVERSAL MEDIA VAULT DATA MODELS
// ============================================

/**
 * Types of media that can be stored in the vault
 */
enum class VaultMediaType(val displayName: String, val icon: String) {
    AUDIO("Audio", "üéµ"),
    VIDEO("Video", "üé¨"),
    PODCAST("Podcast", "üéôÔ∏è"),
    CLIP("Clip", "‚úÇÔ∏è"),
    VOICE_NOTE("Voice Note", "üé§"),
    REMIX("Remix", "üéöÔ∏è"),
    ROOM_RECORDING("Room Recording", "üì°"),
    DOWNLOADED("Downloaded", "‚¨áÔ∏è")
}

/**
 * Source of the media file
 */
enum class MediaSource(val displayName: String) {
    DOWNLOAD("Downloaded"),
    PODCAST("Podcast"),
    REMIX_STUDIO("Remix Studio"),
    AUDIO_ROOM("Audio Room"),
    VOICE_RECORDER("Voice Recorder"),
    DEVICE_IMPORT("Device Import"),
    CLOUD_SYNC("Cloud Sync"),
    UNKNOWN("Unknown")
}

/**
 * Core media item in the vault
 */
data class VaultMediaItem(
    val id: String = UUID.randomUUID().toString(),
    val uri: String,
    val fileName: String,
    val displayName: String,
    val mediaType: VaultMediaType,
    val source: MediaSource = MediaSource.UNKNOWN,

    // Technical metadata
    val metadata: MediaMetadata = MediaMetadata(),

    // Playback data
    val playbackData: PlaybackData = PlaybackData(),

    // Organization
    val collections: List<String> = emptyList(),
    val tags: List<String> = emptyList(),
    val folder: String? = null,

    // Content analysis
    val transcript: MediaTranscript? = null,
    val chapters: List<MediaChapter> = emptyList(),
    val speakers: List<Speaker> = emptyList(),

    // Timestamps
    val addedAt: Long = System.currentTimeMillis(),
    val modifiedAt: Long = System.currentTimeMillis(),
    val lastPlayedAt: Long? = null,

    // Status
    val isFavorite: Boolean = false,
    val isArchived: Boolean = false,
    val isEncrypted: Boolean = false,
    val isOfflineAvailable: Boolean = true,

    // Thumbnail/artwork
    val thumbnailUri: String? = null,
    val artworkUri: String? = null,
    val dominantColor: Long? = null
)

/**
 * Technical metadata for media files
 */
data class MediaMetadata(
    val duration: Long = 0L,           // milliseconds
    val fileSize: Long = 0L,           // bytes
    val mimeType: String = "",
    val codec: String = "",
    val bitrate: Int = 0,              // kbps
    val sampleRate: Int = 0,           // Hz
    val channels: Int = 0,

    // Video specific
    val width: Int = 0,
    val height: Int = 0,
    val frameRate: Float = 0f,
    val hasVideo: Boolean = false,

    // Additional
    val artist: String? = null,
    val album: String? = null,
    val genre: String? = null,
    val year: Int? = null,
    val trackNumber: Int? = null,
    val description: String? = null
)

/**
 * Playback-related data
 */
data class PlaybackData(
    val playCount: Int = 0,
    val totalPlayTime: Long = 0L,      // milliseconds
    val lastPosition: Long = 0L,       // resume position
    val isCompleted: Boolean = false,
    val bookmarks: List<Bookmark> = emptyList(),
    val playbackSpeed: Float = 1f
)

/**
 * Bookmark within media
 */
data class Bookmark(
    val id: String = UUID.randomUUID().toString(),
    val position: Long,                // milliseconds
    val label: String = "",
    val note: String = "",
    val color: Long = 0xFFE91E63,
    val createdAt: Long = System.currentTimeMillis()
)

/**
 * Chapter marker
 */
data class MediaChapter(
    val id: String = UUID.randomUUID().toString(),
    val startTime: Long,
    val endTime: Long,
    val title: String,
    val description: String = "",
    val thumbnailUri: String? = null,
    val isAutoGenerated: Boolean = false
)

/**
 * Speaker identification
 */
data class Speaker(
    val id: String = UUID.randomUUID().toString(),
    val name: String,
    val color: Long = 0xFF2196F3,
    val segments: List<SpeakerSegment> = emptyList()
)

data class SpeakerSegment(
    val startTime: Long,
    val endTime: Long
)

/**
 * Transcript data
 */
data class MediaTranscript(
    val id: String = UUID.randomUUID().toString(),
    val language: String = "en",
    val segments: List<TranscriptSegment> = emptyList(),
    val fullText: String = "",
    val isAutoGenerated: Boolean = true,
    val accuracy: Float = 0f,
    val generatedAt: Long = System.currentTimeMillis()
)

data class TranscriptSegment(
    val startTime: Long,
    val endTime: Long,
    val text: String,
    val speakerId: String? = null,
    val confidence: Float = 1f
)

// ============================================
// üìÅ COLLECTIONS & ORGANIZATION
// ============================================

/**
 * User-created collection
 */
data class MediaCollection(
    val id: String = UUID.randomUUID().toString(),
    val name: String,
    val description: String = "",
    val coverUri: String? = null,
    val color: Long = 0xFFE91E63,
    val icon: String = "üìÅ",
    val itemIds: List<String> = emptyList(),
    val isSmartCollection: Boolean = false,
    val smartRule: SmartCollectionRule? = null,
    val createdAt: Long = System.currentTimeMillis(),
    val modifiedAt: Long = System.currentTimeMillis(),
    val isPinned: Boolean = false
)

/**
 * Rule for smart/auto collections
 */
data class SmartCollectionRule(
    val conditions: List<RuleCondition> = emptyList(),
    val matchAll: Boolean = true,      // AND vs OR
    val sortBy: SortOption = SortOption.DATE_ADDED,
    val sortDescending: Boolean = true,
    val limit: Int? = null
)

data class RuleCondition(
    val field: RuleField,
    val operator: RuleOperator,
    val value: String
)

enum class RuleField {
    MEDIA_TYPE,
    SOURCE,
    TAG,
    SPEAKER,
    DURATION,
    DATE_ADDED,
    DATE_PLAYED,
    PLAY_COUNT,
    IS_FAVORITE,
    HAS_TRANSCRIPT,
    FILE_SIZE
}

enum class RuleOperator {
    EQUALS,
    NOT_EQUALS,
    CONTAINS,
    GREATER_THAN,
    LESS_THAN,
    BETWEEN,
    IN_LAST_DAYS
}

enum class SortOption(val displayName: String) {
    DATE_ADDED("Date Added"),
    DATE_MODIFIED("Date Modified"),
    DATE_PLAYED("Last Played"),
    NAME("Name"),
    DURATION("Duration"),
    FILE_SIZE("File Size"),
    PLAY_COUNT("Play Count")
}

// ============================================
// üîç SEARCH & FILTERS
// ============================================

/**
 * Search query parameters
 */
data class VaultSearchQuery(
    val text: String = "",
    val searchIn: Set<SearchField> = setOf(SearchField.TITLE),
    val mediaTypes: Set<VaultMediaType> = emptySet(),
    val sources: Set<MediaSource> = emptySet(),
    val dateRange: DateRange? = null,
    val durationRange: DurationRange? = null,
    val speakers: List<String> = emptyList(),
    val tags: List<String> = emptyList(),
    val collections: List<String> = emptyList(),
    val onlyFavorites: Boolean = false,
    val onlyUnplayed: Boolean = false,
    val onlyWithTranscript: Boolean = false,
    val sortBy: SortOption = SortOption.DATE_ADDED,
    val sortDescending: Boolean = true
)

enum class SearchField {
    TITLE,
    DESCRIPTION,
    TRANSCRIPT,
    TAGS,
    SPEAKER_NAME,
    CHAPTER_TITLE,
    BOOKMARK_NOTE
}

data class DateRange(
    val start: Long,
    val end: Long
)

data class DurationRange(
    val minMs: Long,
    val maxMs: Long
)

/**
 * Search result with highlight info
 */
data class SearchResult(
    val item: VaultMediaItem,
    val matchedFields: List<SearchField>,
    val highlights: List<SearchHighlight>,
    val relevanceScore: Float
)

data class SearchHighlight(
    val field: SearchField,
    val text: String,
    val matchStart: Int,
    val matchEnd: Int,
    val timestamp: Long? = null  // For transcript matches
)

// ============================================
// üìä VAULT STATISTICS
// ============================================

data class VaultStatistics(
    val totalItems: Int = 0,
    val totalSize: Long = 0L,
    val totalDuration: Long = 0L,
    val itemsByType: Map<VaultMediaType, Int> = emptyMap(),
    val itemsBySource: Map<MediaSource, Int> = emptyMap(),
    val totalPlayTime: Long = 0L,
    val favoritesCount: Int = 0,
    val collectionsCount: Int = 0,
    val transcribedCount: Int = 0,
    val encryptedCount: Int = 0,
    val duplicatesDetected: Int = 0
)

// ============================================
// üîê SECURITY & SYNC
// ============================================

data class VaultSettings(
    val enableEncryption: Boolean = false,
    val encryptionKey: String? = null,
    val autoIngestDownloads: Boolean = true,
    val autoIngestPodcasts: Boolean = true,
    val autoIngestRemixes: Boolean = true,
    val autoTranscribe: Boolean = false,
    val autoChapterDetection: Boolean = false,
    val duplicateDetection: Boolean = true,
    val retentionDays: Int? = null,    // null = keep forever
    val maxStorageBytes: Long? = null,
    val syncEnabled: Boolean = false,
    val syncEncrypted: Boolean = true,
    val lastSyncAt: Long? = null
)

// ============================================
// üìã VAULT STATE
// ============================================

data class VaultState(
    val items: List<VaultMediaItem> = emptyList(),
    val collections: List<MediaCollection> = emptyList(),
    val statistics: VaultStatistics = VaultStatistics(),
    val settings: VaultSettings = VaultSettings(),
    val searchQuery: VaultSearchQuery? = null,
    val searchResults: List<SearchResult> = emptyList(),
    val isLoading: Boolean = false,
    val isSearching: Boolean = false,
    val selectedItems: Set<String> = emptySet(),
    val currentFolder: String? = null,
    val viewMode: VaultViewMode = VaultViewMode.GRID
)

enum class VaultViewMode {
    GRID,
    LIST,
    COMPACT
}

// ============================================
// üéØ DEFAULT SMART COLLECTIONS
// ============================================

val defaultSmartCollections = listOf(
    MediaCollection(
        id = "favorites",
        name = "Favorites",
        icon = "‚ù§Ô∏è",
        color = 0xFFE91E63,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.IS_FAVORITE, RuleOperator.EQUALS, "true")
            )
        ),
        isPinned = true
    ),
    MediaCollection(
        id = "recent",
        name = "Recently Added",
        icon = "üïê",
        color = 0xFF2196F3,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.DATE_ADDED, RuleOperator.IN_LAST_DAYS, "7")
            ),
            sortBy = SortOption.DATE_ADDED
        ),
        isPinned = true
    ),
    MediaCollection(
        id = "podcasts",
        name = "Podcasts",
        icon = "üéôÔ∏è",
        color = 0xFF9C27B0,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.MEDIA_TYPE, RuleOperator.EQUALS, VaultMediaType.PODCAST.name)
            )
        )
    ),
    MediaCollection(
        id = "downloads",
        name = "Downloads",
        icon = "‚¨áÔ∏è",
        color = 0xFF4CAF50,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.SOURCE, RuleOperator.EQUALS, MediaSource.DOWNLOAD.name)
            )
        )
    ),
    MediaCollection(
        id = "videos",
        name = "Videos",
        icon = "üé¨",
        color = 0xFFFF5722,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.MEDIA_TYPE, RuleOperator.EQUALS, VaultMediaType.VIDEO.name)
            )
        )
    ),
    MediaCollection(
        id = "clips",
        name = "My Clips",
        icon = "‚úÇÔ∏è",
        color = 0xFF00BCD4,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.MEDIA_TYPE, RuleOperator.EQUALS, VaultMediaType.CLIP.name)
            )
        )
    ),
    MediaCollection(
        id = "long_content",
        name = "Long Content",
        icon = "üìö",
        color = 0xFF795548,
        isSmartCollection = true,
        smartRule = SmartCollectionRule(
            conditions = listOf(
                RuleCondition(RuleField.DURATION, RuleOperator.GREATER_THAN, "3600000") // > 1 hour
            )
        )
    )
)

